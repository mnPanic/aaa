\documentclass{article}

% Matemática
\usepackage{amsmath}    % símbolos matemáticos
\usepackage{amsthm}     % teoremas
\usepackage{amsfonts}   % \mathbb
\usepackage{amssymb}    % \therefore
\usepackage{bm}         % bold math (https://ctan.org/pkg/bm)
\usepackage{abraces}    % \aoverbrace http://ctan.org/pkg/abraces
% https://tex.stackexchange.com/questions/132526/overbrace-and-underbrace-with-square-bracket

\usepackage[makeroom]{cancel}   % \cancel

% Figuras
\usepackage{tikz}                   % gráficos
\usepackage{float}                  % [H]
\usepackage{xcolor}                 % colores https://es.overleaf.com/learn/latex/Using_colours_in_LaTeX

% Formateo
\usepackage{framed}     % env leftbar

% Texto
\usepackage[shortlabels]{enumitem}  % enumerate con letras

% Referencias
\usepackage[colorlinks=true]{hyperref}

% Código
% https://tex.stackexchange.com/questions/51295/algpseudocode-without-end-block-text
\usepackage[noend]{algpseudocode} % env algorithmic,
\usepackage{algorithm}
\usepackage{algorithmicx}


% Diagramas
\usepackage{tikz}
\usetikzlibrary{automata, arrows, positioning}

\tikzset{
    ->, % makes the edges directed
    >=stealth', % makes the arrow heads bold
    node distance=3cm, % specifies the minimum distance between two nodes. Change if necessary.
    every state/.style={thick}, % sets the properties for each 'state' node
    initial text=$ $, % sets the text that appears on the start arrow
}


\usepackage{mathtools}
% Macros para símbolos
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\BigO}{\mathcal{O}}

% Teoremas, corolarios, etc.
% https://www.overleaf.com/learn/latex/theorems_and_proofs
\theoremstyle{definition} % Para que no salga en italicas

\newtheorem{theorem}{Teorema}
\newtheorem*{theorem*}{Teorema}

\newtheorem{lemma}{Lema}
\newtheorem*{lemma*}{Lema}

\newtheorem{proposition}{Prop.}
\newtheorem*{proposition*}{Prop}

\newtheorem{corollary}{Corolario}
\newtheorem*{corollary*}{Corolario}

\newtheorem{definition}{Def.}
\newtheorem*{definition*}{Def}

\newtheorem*{observation*}{Obs}

\newtheorem{example}{Ejemplo}
\newtheorem*{example*}{Ejemplo}

% Comandos de AAA
\newcommand{\select}{\upharpoonright}
\newcommand{\progends}{\downarrow}
\newcommand{\firstn}[1]{\first{n}{#1}}
\newcommand{\first}[2]{#2[1 \dots #1]}

% Entornos
\newenvironment{nota}[1]
    {\begin{leftbar}\textbf{#1}}
    {\end{leftbar}}

\author{Manuel Panichelli}
\title{Algoritmos, Azar y Autómatas\\Resolución Ejercicios 9 a 13 (Aleatoriedad)}

\begin{document}
\maketitle

\section*{Resultados previos}

TODO: programa elegante, complejidad de kormogolov, definiciones de martin lof y
etc.

\section*{Ejercicio 9}

\textit{Demostrar que los números Martin-Löf aleatorios son normales.}

\section*{Ejercicio 10}

\textit{Dar un algoritmo que permite computar $\Omega$ con un oráculo para el problema de la detención.}

Recuerdo la definición de $\Omega$, la suma de las potencias de 2 de las
longitudes de todos los programas que terminan. Si U es una máquina de Turing
universal,

\[
    \Omega = \sum_{U(p)\progends} 2 ^ {-|p|}
\]

Para computar $\Omega$ voy a dar una función que computa los primeros $n$
dígitos, $\firstn{\Omega}$, y luego voy incrementando $n$ e imprimiendo los
resultados.

Sea $g$ una enumeración de todos los programas que terminan (se
podría obtener computablemente mediante un método como \textit{dovetailing}),
defino una aproximación de $\Omega$ hasta el m-ésimo programa,

\[
    \alpha_m = \sum_{j = 1}^{m} 2 ^ {-|g(j)|}
\]

Lo que me gustaría saber es para qué $m$ $\alpha_m$ tiene los primeros $n$
dígitos \textit{definitivos}, es decir $\firstn{\Omega} = \firstn{\alpha_m}$.
Para ello, debo verificar que

\[
    \firstn{\alpha_m} \overset{?}{=} \firstn{\alpha_m'}\ \forall m' > m
\]

Es decir, no importa que sigamos considerando más programas, los primeros $n$
dígitos no van a cambiar. Como no es algo finito, no lo podemos computar con un
algoritmo, pero acá es donde nos salva el oráculo de Halt. La siguiente función
logra lo buscado

\begin{algorithmic}
    \Function{Q}{m, n}
        \State $m' \gets m + 1$
        \While{true}
            \If{$\firstn{\alpha_m} \neq \firstn{\alpha_m'}$}
            \State \textbf{break}
            \EndIf
            \State $m' \gets m' + 1$
        \EndWhile
    \EndFunction
\end{algorithmic}

\begin{itemize}
    \item Si \texttt{OraculoHalt(Q(m, n)) = true} (es decir, Q termina) es
    porque existía $m$ tal que cambiaban los primeros $n$ dígitos, y por lo
    tanto no eran definitivos.

    \item Si \texttt{OraculoHalt(Q(m, n)) = false} (es decir, Q \textit{no}
    termina), entonces no existe $m$ tal que cambien los primeros $n$ dígitos, y
    por lo tanto son definitivos.
\end{itemize}

El algoritmo final es el siguiente, donde la función sin argumentos Print
$\Omega$ imprime $\Omega$ segmento inicial por segmento inicial.

\begin{algorithmic}
    \Function{Print $\Omega$}{}

        \For{$n = 1, 2 \dots$}
            \State \textbf{print} \Call{$\Omega$}{n}
        \EndFor

    \EndFunction

    \Function{$\Omega$}{n}

    \For{$m = 1, 2 \dots$}
        \If{$\neg$ OraculoHalt(\Call{Q}{m, n})}
            \State \textbf{return} $\firstn{\alpha_m}$
        \EndIf
    \EndFor

\EndFunction

    \Function{Q}{m, n}
        \State $m' \gets m + 1$
        \While{true}
            \If{$\firstn{\alpha_m} \neq \firstn{\alpha_m'}$}
            \State \textbf{break}
            \EndIf
            \State $m' \gets m' + 1$
        \EndWhile
    \EndFunction
\end{algorithmic}

\newpage

\section*{Ejercicio 11}

\textit{Salteado porque no era necesario resolverlo.}

\section*{Ejercicio 12}

\subsection*{12.1}

\textit{Demostrar que el número $(1 - \Omega)$ es aleatorio}

\begin{proposition}\label{prop:xor-bits}
    Con los bits de $x$ puedo obtener los de $\bar{x} = 1 - x$ realizando un xor con
    todos 1s, $x \oplus 1s = \bar{x}$.
\end{proposition}

\begin{proof}
    Sea $g: \mathbb{N} \to \Sigma^*$ una enumeración de los programas que se
    detienen, $\alpha_m = \sum_{j = 1}^{m} 2 ^ {-|g(j)|}$ una aproximación de
    $\Omega$ de $m$ pasos. Defino el programa $p$,

    \[
        p = b_1 b_2 \dots b_c \first{i}{\bar{\Omega}}^*
    \]

    donde $\first{i}{\Omega}^*$ es una subrutina que es el
    programa elegante (el más corto) que computa $\first{i}{\Omega}$ y $b_1 b_2
    \dots b_c$ realiza los siguientes pasos,

    \begin{enumerate}
        \item[0.] Computamos $\first{i}{\bar{\Omega}}$ con
        $\first{i}{\bar{\Omega}}^*$
        \item Computamos $\first{i}{\Omega}$ en base a
        $\first{i}{\bar{\Omega}}$ mediante un $\oplus$ con todos 1s.
        \item $m = 1$. Mientras ($\alpha_m \leq \first{i}{\Omega}$), $m = m + 1$.
        \item Sea $O = \{ U(g(j)) \mid 1 \leq j \leq m \}$ los outputs de los
        programas que se detienen que aportan a la aproximación de $\Omega$
        \item Sea $s$ la cadena más chica lexicográficamente tal que $s \notin O$.
        \item Return $s$.
    \end{enumerate}

    Veamos que $|s^*| > i$, la longitud del programa elegante que computa $s$
    (su complejidad) es más chica que $i$. Para demostrarlo supongamos lo
    contrario, que $|s^*| \leq i$

    \begin{align*}
        \Omega 
        &> 2^{-|s^*|} + \alpha_m
            &&\text{($\Omega$ tiene infinitos aportes)}\\
        &> 2^{-|s^*|} + \first{i}{\Omega}
            &&\text{(porque $\alpha_m > \first{i}{\Omega}$)}\\
        &\geq 2^{-i} + \first{i}{\Omega}
            &&\text{(sup. $|s^*| \leq i$)}\\
        &\geq \Omega
            &&\text{($\first{i}{\Omega}$ contiene exactamente los primeros $i$ bits de $\Omega$)}
    \end{align*}

    Y llegamos a $\Omega > \Omega$ que es un absurdo. Por lo tanto, $|s^*| > i$.
    
    Por otro lado, como $p$ es un programa (no muy bueno) que computa $s$, se que

    \begin{equation}\label{eq:comp}
         K(s) \leq c + |\first{i}{\bar{\Omega}}^*|
    \end{equation}

    donde $c = |b_1 \dots b_c|$.

    Juntando,

    \begin{align*}
        i
            &< |s^*|\\
            &= K(s)\\
            &\leq c + |\first{i}{\bar{\Omega}}^*| &&\text{por (\ref{eq:comp})}\\
            &= c + K(\first{i}{\bar{\Omega}})
    \end{align*}

    $\iff K(\first{i}{\bar{\Omega}}) > i - c$, que es la definición de
    aleatoriedad de Chaitin.

\end{proof}

\subsection*{12.2}

\textit{Para todo conjunto $X$ infinito y c.e pero no computable, $\sum_{x \in
X} 2^{-|x|}$ es aleatorio.}

\subsection*{12.3}

\textit{El número $\Omega_0$ que resulta de anteponer mil 0s delante de $\Omega$ es aleatorio.}

\subsection*{12.4}

\textit{Demostrar que $\sum_{\text{palabra s}} 2^{K(s)}$ es computablemente
aproximable desde abajo y Martin Löf aleatorio.}

\section*{Ejercicio 13}

\textit{Dar un test de Martin Löf que contenga a los números decimales cuya expansión decimal no contiene el 7.}

\end{document}